#!/usr/bin/env python
#
# Autogenerated by Thrift Compiler (1.0.0-dev)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

import sys
import pprint
from urlparse import urlparse
from thrift.transport import TTransport
from thrift.transport import TSocket
from thrift.transport import THttpClient
from thrift.protocol import TBinaryProtocol

from thrift import SessionTracker
from thrift.ttypes import *

if len(sys.argv) <= 1 or sys.argv[1] == '--help':
  print('')
  print('Usage: ' + sys.argv[0] + ' [-h host[:port]] [-u url] [-f[ramed]] function [arg1 [arg2...]]')
  print('')
  print('Functions:')
  print('  i64 next_i_call()')
  print('  i64 current_i_call()')
  print('  i64 next_i_cdrs_connection()')
  print('  void b2bua_stopped(string b2bua_id, MonoTime rtime)')
  print('  void register_b2bua(string b2bua_id, string uri, i32 pid)')
  print('  void call_error(NullInt64 parent_i_call, i64 i_account, string cli, string cld, double cost, string call_id, MonoTime setup_ts, string remote_ip, string cli_orig, string cld_orig, string user_agent, i32 result, NullString lrn_cld_in, NullString lrn_cld, NullString p_asserted_id, NullInt64 i_call_type, BuyingDidBillables buying_dcg, NullString remote_party_id)')
  print('  i64 register_call(NullInt64 parent_i_call, i64 i_account, bool disallow_loops, i32 acc_max_sessions, string call_id, string cld, string cli, MonoTime setup_ts, i64 i_billing_plan, bool billing_plan_suspended, AccountBillables account_billables, Billables accessibility_billables, string remote_ip, string cli_orig, string cld_orig, i16 i_protocol, string user_agent, double max_calls_per_second, double translation_cost, DidBillables did_charging_group, bool is_late_dcg, i64 average_duration, i64 max_credit_time, string sess_id, bool round_up, NullString p_asserted_id, NullInt64 i_call_type, NullString remote_party_id)')
  print('  void register_virtual(string bind_session_id, i64 i_call, string remote_ip, string cli_orig, string cld_orig, i16 i_protocol, string user_agent, i64 i_account, i64 i_billing_plan, bool billing_plan_suspended, string cld, AccountBillables account_billables, Billables accessibility_billables, MonoTime rtime, double translation_cost, i64 max_credit_time, string sess_id, bool round_up, NullString p_asserted_id, NullString remote_party_id)')
  print('   stats_all()')
  print('   stats_total()')
  print('  void sess_started(string sess_id, MonoTime rtime, Duration crtime_ext, MonoTime p1xx_ts)')
  print('  void write_cdr(i64 i_account, double duration, double delay, double pdd1xx, bool connected, AccountBillables account_billables, Billables accessibility_billables,  customer_billables, MonoTime rtime, string origin, i32 result, i64 i_billing_plan, i64 i_call, string remote_ip, string cld, string cli_orig, string cld_orig, MonoTime setup_ts, string user_agent, i16 i_protocol, double translation_cost, DidBillables dcg, bool is_late_dcg, bool billing_plan_suspended, NullString lrn_cld_in, NullString lrn_cld, bool round_up, NullString p_asserted_id, BuyingDidBillables buying_dcg, NullString remote_party_id,  sdp_list,  customer_dcgs)')
  print('  void sess_ended(string b2bua_id, string sess_id,  customer_billables, double duration, double delay, double pdd1xx, bool connected, MonoTime rtime, string origin, i32 result, NullString lrn_cld_in, NullString lrn_cld, BuyingDidBillables buying_dcg,  sdp_list,  customer_dcgs)')
  print('')
  sys.exit(0)

pp = pprint.PrettyPrinter(indent = 2)
host = 'localhost'
port = 9090
uri = ''
framed = False
http = False
argi = 1

if sys.argv[argi] == '-h':
  parts = sys.argv[argi+1].split(':')
  host = parts[0]
  if len(parts) > 1:
    port = int(parts[1])
  argi += 2

if sys.argv[argi] == '-u':
  url = urlparse(sys.argv[argi+1])
  parts = url[1].split(':')
  host = parts[0]
  if len(parts) > 1:
    port = int(parts[1])
  else:
    port = 80
  uri = url[2]
  if url[4]:
    uri += '?%s' % url[4]
  http = True
  argi += 2

if sys.argv[argi] == '-f' or sys.argv[argi] == '-framed':
  framed = True
  argi += 1

cmd = sys.argv[argi]
args = sys.argv[argi+1:]

if http:
  transport = THttpClient.THttpClient(host, port, uri)
else:
  socket = TSocket.TSocket(host, port)
  if framed:
    transport = TTransport.TFramedTransport(socket)
  else:
    transport = TTransport.TBufferedTransport(socket)
protocol = TBinaryProtocol.TBinaryProtocol(transport)
client = SessionTracker.Client(protocol)
transport.open()

if cmd == 'next_i_call':
  if len(args) != 0:
    print('next_i_call requires 0 args')
    sys.exit(1)
  pp.pprint(client.next_i_call())

elif cmd == 'current_i_call':
  if len(args) != 0:
    print('current_i_call requires 0 args')
    sys.exit(1)
  pp.pprint(client.current_i_call())

elif cmd == 'next_i_cdrs_connection':
  if len(args) != 0:
    print('next_i_cdrs_connection requires 0 args')
    sys.exit(1)
  pp.pprint(client.next_i_cdrs_connection())

elif cmd == 'b2bua_stopped':
  if len(args) != 2:
    print('b2bua_stopped requires 2 args')
    sys.exit(1)
  pp.pprint(client.b2bua_stopped(args[0],eval(args[1]),))

elif cmd == 'register_b2bua':
  if len(args) != 3:
    print('register_b2bua requires 3 args')
    sys.exit(1)
  pp.pprint(client.register_b2bua(args[0],args[1],eval(args[2]),))

elif cmd == 'call_error':
  if len(args) != 18:
    print('call_error requires 18 args')
    sys.exit(1)
  pp.pprint(client.call_error(eval(args[0]),eval(args[1]),args[2],args[3],eval(args[4]),args[5],eval(args[6]),args[7],args[8],args[9],args[10],eval(args[11]),eval(args[12]),eval(args[13]),eval(args[14]),eval(args[15]),eval(args[16]),eval(args[17]),))

elif cmd == 'register_call':
  if len(args) != 28:
    print('register_call requires 28 args')
    sys.exit(1)
  pp.pprint(client.register_call(eval(args[0]),eval(args[1]),eval(args[2]),eval(args[3]),args[4],args[5],args[6],eval(args[7]),eval(args[8]),eval(args[9]),eval(args[10]),eval(args[11]),args[12],args[13],args[14],eval(args[15]),args[16],eval(args[17]),eval(args[18]),eval(args[19]),eval(args[20]),eval(args[21]),eval(args[22]),args[23],eval(args[24]),eval(args[25]),eval(args[26]),eval(args[27]),))

elif cmd == 'register_virtual':
  if len(args) != 20:
    print('register_virtual requires 20 args')
    sys.exit(1)
  pp.pprint(client.register_virtual(args[0],eval(args[1]),args[2],args[3],args[4],eval(args[5]),args[6],eval(args[7]),eval(args[8]),eval(args[9]),args[10],eval(args[11]),eval(args[12]),eval(args[13]),eval(args[14]),eval(args[15]),args[16],eval(args[17]),eval(args[18]),eval(args[19]),))

elif cmd == 'stats_all':
  if len(args) != 0:
    print('stats_all requires 0 args')
    sys.exit(1)
  pp.pprint(client.stats_all())

elif cmd == 'stats_total':
  if len(args) != 0:
    print('stats_total requires 0 args')
    sys.exit(1)
  pp.pprint(client.stats_total())

elif cmd == 'sess_started':
  if len(args) != 4:
    print('sess_started requires 4 args')
    sys.exit(1)
  pp.pprint(client.sess_started(args[0],eval(args[1]),eval(args[2]),eval(args[3]),))

elif cmd == 'write_cdr':
  if len(args) != 32:
    print('write_cdr requires 32 args')
    sys.exit(1)
  pp.pprint(client.write_cdr(eval(args[0]),eval(args[1]),eval(args[2]),eval(args[3]),eval(args[4]),eval(args[5]),eval(args[6]),eval(args[7]),eval(args[8]),args[9],eval(args[10]),eval(args[11]),eval(args[12]),args[13],args[14],args[15],args[16],eval(args[17]),args[18],eval(args[19]),eval(args[20]),eval(args[21]),eval(args[22]),eval(args[23]),eval(args[24]),eval(args[25]),eval(args[26]),eval(args[27]),eval(args[28]),eval(args[29]),eval(args[30]),eval(args[31]),))

elif cmd == 'sess_ended':
  if len(args) != 15:
    print('sess_ended requires 15 args')
    sys.exit(1)
  pp.pprint(client.sess_ended(args[0],args[1],eval(args[2]),eval(args[3]),eval(args[4]),eval(args[5]),eval(args[6]),eval(args[7]),args[8],eval(args[9]),eval(args[10]),eval(args[11]),eval(args[12]),eval(args[13]),eval(args[14]),))

else:
  print('Unrecognized method %s' % cmd)
  sys.exit(1)

transport.close()
